// ***DO NOT EDIT THIS FILE - IT IS AUTOMATICALLY GENERATED BY CMAKE***

#include <osgEarthDrivers/sky_simple/SimpleSkyShaders>


using namespace osgEarth::Drivers::SimpleSky;

Shaders::Shaders()
{
    Atmosphere_Vert = "SimpleSky.Atmosphere.vert.glsl";
    _sources[Atmosphere_Vert] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR\n
$GLSL_DEFAULT_PRECISION_FLOAT\n
\n
$__HASHTAG__pragma vp_entryPoint "atmos_vertex_main"\n
$__HASHTAG__pragma vp_location   "vertex_view"\n
$__HASHTAG__pragma vp_order      "0.5"\n
\n
// Atmospheric Scattering and Sun Shaders\n
// Adapted from code that is Copyright (c) 2004 Sean ONeil\n
\n
uniform mat4 osg_ViewMatrixInverse;   // camera position in [3].xyz\n
uniform vec3 atmos_v3LightDir;        // The direction vector to the light source \n
uniform vec3 atmos_v3InvWavelength;   // 1 / pow(wavelength,4) for the rgb channels \n
uniform float atmos_fOuterRadius;     // Outer atmosphere radius \n
uniform float atmos_fOuterRadius2;    // fOuterRadius^2 		\n
uniform float atmos_fInnerRadius;     // Inner planetary radius \n
uniform float atmos_fInnerRadius2;    // fInnerRadius^2 \n
uniform float atmos_fKrESun;          // Kr * ESun 	\n
uniform float atmos_fKmESun;          // Km * ESun 		\n
uniform float atmos_fKr4PI;           // Kr * 4 * PI 	\n
uniform float atmos_fKm4PI;           // Km * 4 * PI 		\n
uniform float atmos_fScale;           // 1 / (fOuterRadius - fInnerRadius) 	\n
uniform float atmos_fScaleDepth;      // The scale depth \n
uniform float atmos_fScaleOverScaleDepth;     // fScale / fScaleDepth 	\n
uniform int atmos_nSamples; 	\n
uniform float atmos_fSamples; 				\n
\n
varying vec3 atmos_v3Direction; \n
varying vec3 atmos_mieColor; \n
varying vec3 atmos_rayleighColor; \n
\n
vec3 vVec; \n
float atmos_fCameraHeight;    // The camera's current height 		\n
float atmos_fCameraHeight2;   // fCameraHeight^2 \n
\n
float atmos_fastpow(in float x, in float y) \n
{ \n
    return x/(x+y-y*x); \n
} \n
\n
float atmos_scale(float fCos) 	\n
{ \n
    float x = 1.0 - fCos; \n
    return atmos_fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25)))); \n
} \n
\n
void atmos_SkyFromSpace(void) \n
{ \n
    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere) \n
    vec3 v3Pos = gl_Vertex.xyz; \n
    vec3 v3Ray = v3Pos - vVec; \n
    float fFar = length(v3Ray); \n
    v3Ray /= fFar; \n
\n
    // Calculate the closest intersection of the ray with the outer atmosphere \n
    // (which is the near point of the ray passing through the atmosphere) \n
    float B = 2.0 * dot(vVec, v3Ray); \n
    float C = atmos_fCameraHeight2 - atmos_fOuterRadius2; \n
    float fDet = max(0.0, B*B - 4.0 * C); 	\n
    float fNear = 0.5 * (-B - sqrt(fDet)); 		\n
\n
    // Calculate the ray's starting position, then calculate its scattering offset \n
    vec3 v3Start = vVec + v3Ray * fNear; 			\n
    fFar -= fNear; 	\n
    float fStartAngle = dot(v3Ray, v3Start) / atmos_fOuterRadius; 			\n
    float fStartDepth = exp(-1.0 / atmos_fScaleDepth); \n
    float fStartOffset = fStartDepth*atmos_scale(fStartAngle); 		\n
\n
    // Initialize the atmos_ing loop variables 	\n
    float fSampleLength = fFar / atmos_fSamples; 		\n
    float fScaledLength = fSampleLength * atmos_fScale; 					\n
    vec3 v3SampleRay = v3Ray * fSampleLength; 	\n
    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5; 	\n
\n
    // Now loop through the sample rays \n
    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); \n
    vec3 v3Attenuate;   \n
    for(int i=0; i<atmos_nSamples; i++) 		\n
    { \n
        float fHeight = length(v3SamplePoint); 			\n
        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); \n
        float fLightAngle = dot(atmos_v3LightDir, v3SamplePoint) / fHeight; 		\n
        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight; 			\n
        float fscatter = (fStartOffset + fDepth*(atmos_scale(fLightAngle) - atmos_scale(fCameraAngle))); 	\n
        v3Attenuate = exp(-fscatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	\n
        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 					\n
        v3SamplePoint += v3SampleRay; 		\n
    } 		\n
\n
    // Finally, scale the Mie and Rayleigh colors and set up the varying 			\n
    // variables for the pixel shader 	\n
    atmos_mieColor      = v3FrontColor * atmos_fKmESun; 				\n
    atmos_rayleighColor = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun); 						\n
    atmos_v3Direction = vVec  - v3Pos; 			\n
} 		\n
\n
void atmos_SkyFromAtmosphere(void) 		\n
{ \n
    // Get the ray from the camera to the vertex, and its length (which is the far \n
    // point of the ray passing through the atmosphere) \n
    vec3 v3Pos = gl_Vertex.xyz; 	\n
    vec3 v3Ray = v3Pos - vVec; 			\n
    float fFar = length(v3Ray); 					\n
    v3Ray /= fFar; 				\n
\n
    // Calculate the ray's starting position, then calculate its atmos_ing offset \n
    vec3 v3Start = vVec; \n
    float fHeight = length(v3Start); 		\n
    float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - atmos_fCameraHeight)); \n
    float fStartAngle = dot(v3Ray, v3Start) / fHeight; 	\n
    float fStartOffset = fDepth*atmos_scale(fStartAngle); \n
\n
    // Initialize the atmos_ing loop variables 		\n
    float fSampleLength = fFar / atmos_fSamples; 			\n
    float fScaledLength = fSampleLength * atmos_fScale; 				\n
    vec3 v3SampleRay = v3Ray * fSampleLength; 		\n
    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5; \n
\n
    // Now loop through the sample rays 		\n
    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); 		\n
    vec3 v3Attenuate;   \n
    for(int i=0; i<atmos_nSamples; i++) 			\n
    { 	\n
        float fHeight = length(v3SamplePoint); 	\n
        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); \n
        float fLightAngle = dot(atmos_v3LightDir, v3SamplePoint) / fHeight; \n
        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight; 	\n
        float fscatter = (fStartOffset + fDepth*(atmos_scale(fLightAngle) - atmos_scale(fCameraAngle))); 	\n
        v3Attenuate = exp(-fscatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	\n
        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 		\n
        v3SamplePoint += v3SampleRay; 		\n
    } \n
\n
    // Finally, scale the Mie and Rayleigh colors and set up the varying \n
    // variables for the pixel shader 					\n
    atmos_mieColor      = v3FrontColor * atmos_fKmESun; 			\n
    atmos_rayleighColor = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun); 				\n
    atmos_v3Direction = vVec - v3Pos; 				\n
} \n
\n
void atmos_vertex_main(inout vec4 VertexVIEW) \n
{ \n
    // Get camera position and height \n
    vVec = osg_ViewMatrixInverse[3].xyz; \n
    atmos_fCameraHeight = length(vVec); \n
    atmos_fCameraHeight2 = atmos_fCameraHeight*atmos_fCameraHeight; \n
    if(atmos_fCameraHeight >= atmos_fOuterRadius)\n
    { \n
        atmos_SkyFromSpace(); \n
    } \n
    else\n
    { \n
        atmos_SkyFromAtmosphere(); \n
    } \n
}\n
\n
);

    Atmosphere_Frag = "SimpleSky.Atmosphere.frag.glsl";
    _sources[Atmosphere_Frag] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR\n
$GLSL_DEFAULT_PRECISION_FLOAT\n
\n
$__HASHTAG__pragma vp_entryPoint "atmos_fragment_main"\n
$__HASHTAG__pragma vp_location   "fragment_coloring"\n
$__HASHTAG__pragma vp_order      "0.8"\n
\n
uniform vec3 atmos_v3LightDir; \n
\n
uniform float atmos_g; 				\n
uniform float atmos_g2; \n
uniform float atmos_fWeather; \n
\n
varying vec3 atmos_v3Direction; 	\n
varying vec3 atmos_mieColor; \n
varying vec3 atmos_rayleighColor; \n
\n
const float fExposure = 4.0; \n
\n
float atmos_fastpow(in float x, in float y) \n
{ \n
    return x/(x+y-y*x); \n
} \n
\n
void atmos_fragment_main(inout vec4 color) \n
{ 				\n
    float fCos = dot(atmos_v3LightDir, atmos_v3Direction) / length(atmos_v3Direction); \n
    float fRayleighPhase = 1.0;  // 0.75 * (1.0 + fCos*fCos); \n
    float fMiePhase = 1.5 * ((1.0 - atmos_g2) / (2.0 + atmos_g2)) * (1.0 + fCos*fCos) / atmos_fastpow(1.0 + atmos_g2 - 2.0*atmos_g*fCos, 1.5); \n
    vec3 f4Color = fRayleighPhase * atmos_rayleighColor + fMiePhase * atmos_mieColor; \n
    vec3 skyColor = 1.0 - exp(f4Color * -fExposure); \n
    color.rgb = skyColor.rgb*atmos_fWeather; \n
    color.a = (skyColor.r+skyColor.g+skyColor.b) * 2.0; \n
}\n
\n
);

    Ground_ONeil_Vert = "SimpleSky.Ground.ONeil.vert.glsl";
    _sources[Ground_ONeil_Vert] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR\n
$GLSL_DEFAULT_PRECISION_FLOAT\n
\n
$__HASHTAG__pragma vp_entryPoint "atmos_vertex_main"\n
$__HASHTAG__pragma vp_location   "vertex_view"\n
$__HASHTAG__pragma vp_order      "0.5"\n
\n
uniform bool oe_mode_GL_LIGHTING; \n
\n
uniform mat4 osg_ViewMatrixInverse;   // world camera position in [3].xyz \n
uniform mat4 osg_ViewMatrix;          // GL view matrix \n
uniform vec3 atmos_v3LightDir;        // The direction vector to the light source \n
uniform vec3 atmos_v3InvWavelength;   // 1 / pow(wavelength,4) for the rgb channels \n
uniform float atmos_fOuterRadius;     // Outer atmosphere radius \n
uniform float atmos_fOuterRadius2;    // fOuterRadius^2 		\n
uniform float atmos_fInnerRadius;     // Inner planetary radius \n
uniform float atmos_fInnerRadius2;    // fInnerRadius^2 \n
uniform float atmos_fKrESun;          // Kr * ESun 	\n
uniform float atmos_fKmESun;          // Km * ESun 		\n
uniform float atmos_fKr4PI;           // Kr * 4 * PI 	\n
uniform float atmos_fKm4PI;           // Km * 4 * PI 		\n
uniform float atmos_fScale;           // 1 / (fOuterRadius - fInnerRadius) 	\n
uniform float atmos_fScaleDepth;      // The scale depth \n
uniform float atmos_fScaleOverScaleDepth;     // fScale / fScaleDepth 	\n
uniform int atmos_nSamples; 	\n
uniform float atmos_fSamples; \n
\n
varying vec3 atmos_color;          // primary sky light color\n
varying vec3 atmos_atten;          // sky light attenuation factor\n
varying vec3 atmos_lightDir;       // light direction in view space\n
        \n
float atmos_fCameraHeight;            // The camera's current height 		\n
float atmos_fCameraHeight2;           // fCameraHeight^2 \n
\n
varying vec3 atmos_up;             // earth up vector at vertex location (not the normal)\n
varying float atmos_space;         // [0..1]: camera: 0=inner radius (ground); 1.0=outer radius\n
varying vec3 atmos_vert; \n
\n
vec3 oe_global_Normal;             // surface normal (from osgEarth)\n
\n
float atmos_scale(float fCos) 	\n
{ \n
    float x = 1.0 - fCos; \n
    return atmos_fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25)))); \n
} \n
\n
void atmos_GroundFromSpace(in vec4 vertexVIEW) \n
{ \n
    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere) \n
    vec3 v3Pos = vertexVIEW.xyz; \n
    vec3 v3Ray = v3Pos; \n
    float fFar = length(v3Ray); \n
    v3Ray /= fFar; \n
                \n
    vec4 ec4 = osg_ViewMatrix * vec4(0,0,0,1); \n
    vec3 earthCenter = ec4.xyz/ec4.w; \n
    vec3 normal = normalize(v3Pos-earthCenter); \n
    atmos_up = normal; \n
\n
    // Calculate the closest intersection of the ray with the outer atmosphere \n
    // (which is the near point of the ray passing through the atmosphere) \n
    float B = 2.0 * dot(-earthCenter, v3Ray); \n
    float C = atmos_fCameraHeight2 - atmos_fOuterRadius2; \n
    float fDet = max(0.0, B*B - 4.0*C); 	\n
    float fNear = 0.5 * (-B - sqrt(fDet)); 		\n
\n
    // Calculate the ray's starting position, then calculate its scattering offset \n
    vec3 v3Start = v3Ray * fNear; 			\n
    fFar -= fNear; \n
    float fDepth = exp((atmos_fInnerRadius - atmos_fOuterRadius) / atmos_fScaleDepth);\n
    float fCameraAngle = dot(-v3Ray, normal); \n
    float fLightAngle = dot(atmos_lightDir, normal); \n
    float fCameraScale = atmos_scale(fCameraAngle); \n
    float fLightScale = atmos_scale(fLightAngle); \n
    float fCameraOffset = fDepth*fCameraScale; \n
    float fTemp = fLightScale * fCameraScale; 		\n
\n
    // Initialize the scattering loop variables \n
    float fSampleLength = fFar / atmos_fSamples; 		\n
    float fScaledLength = fSampleLength * atmos_fScale; 					\n
    vec3 v3SampleRay = v3Ray * fSampleLength; 	\n
    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5; 	\n
\n
    // Now loop through the sample rays \n
    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); \n
    vec3 v3Attenuate = vec3(1,0,0); \n
\n
    for(int i=0; i<atmos_nSamples; ++i) \n
    {         \n
        float fHeight = length(v3SamplePoint-earthCenter); 			\n
        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); \n
        float fScatter = fDepth*fTemp - fCameraOffset; \n
        v3Attenuate = exp(-fScatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	\n
        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 					\n
        v3SamplePoint += v3SampleRay; 		\n
    } 	\n
\n
    atmos_color = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun + atmos_fKmESun); \n
    atmos_atten = v3Attenuate; \n
} 		\n
\n
void atmos_GroundFromAtmosphere(in vec4 vertexVIEW) 		\n
{ \n
    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere) \n
    vec3 v3Pos = vertexVIEW.xyz / vertexVIEW.w; \n
    vec3 v3Ray = v3Pos; \n
    float fFar = length(v3Ray); \n
    v3Ray /= fFar; \n
        \n
    vec4 ec4 = osg_ViewMatrix * vec4(0,0,0,1); \n
    vec3 earthCenter = ec4.xyz/ec4.w; \n
    vec3 normal = normalize(v3Pos-earthCenter); \n
    atmos_up = normal; \n
\n
    // Calculate the ray's starting position, then calculate its scattering offset \n
    float fDepth = exp((atmos_fInnerRadius - atmos_fCameraHeight) / atmos_fScaleDepth);\n
    float fCameraAngle = max(0.0, dot(-v3Ray, normal)); \n
    float fLightAngle = dot(atmos_lightDir, normal); \n
    float fCameraScale = atmos_scale(fCameraAngle); \n
    float fLightScale = atmos_scale(fLightAngle); \n
    float fCameraOffset = fDepth*fCameraScale; \n
    float fTemp = fLightScale * fCameraScale; \n
\n
    // Initialize the scattering loop variables 	\n
    float fSampleLength = fFar / atmos_fSamples; 		\n
    float fScaledLength = fSampleLength * atmos_fScale; 					\n
    vec3 v3SampleRay = v3Ray * fSampleLength; 	\n
    vec3 v3SamplePoint = v3SampleRay * 0.5; 	\n
\n
    // Now loop through the sample rays \n
    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0); \n
    vec3 v3Attenuate;   \n
    for(int i=0; i<atmos_nSamples; i++) 		\n
    { \n
        float fHeight = length(v3SamplePoint-earthCenter); 			\n
        float fDepth = exp(atmos_fScaleOverScaleDepth * (atmos_fInnerRadius - fHeight)); \n
        float fScatter = fDepth*fTemp - fCameraOffset; \n
        v3Attenuate = exp(-fScatter * (atmos_v3InvWavelength * atmos_fKr4PI + atmos_fKm4PI)); 	\n
        v3FrontColor += v3Attenuate * (fDepth * fScaledLength); 					\n
        v3SamplePoint += v3SampleRay; 		\n
    } 		\n
\n
    atmos_color = v3FrontColor * (atmos_v3InvWavelength * atmos_fKrESun + atmos_fKmESun); 			\n
    atmos_atten = v3Attenuate; \n
} \n
\n
void atmos_vertex_main(inout vec4 vertexVIEW) \n
{ \n
    if ( oe_mode_GL_LIGHTING == false ) return; \n
\n
    atmos_fCameraHeight = length(osg_ViewMatrixInverse[3].xyz); \n
    atmos_fCameraHeight2 = atmos_fCameraHeight*atmos_fCameraHeight; \n
    atmos_lightDir = normalize(gl_LightSource[0].position.xyz);  // view space\n
    atmos_vert = vertexVIEW.xyz; \n
\n
    atmos_space = max(0.0, (atmos_fCameraHeight-atmos_fInnerRadius)/(atmos_fOuterRadius-atmos_fInnerRadius));\n
\n
    if(atmos_fCameraHeight >= atmos_fOuterRadius) \n
    { \n
        atmos_GroundFromSpace(vertexVIEW); \n
    } \n
    else \n
    { \n
        atmos_GroundFromAtmosphere(vertexVIEW); \n
    } \n
}\n
\n
);

    Ground_ONeil_Frag = "SimpleSky.Ground.ONeil.frag.glsl";
    _sources[Ground_ONeil_Frag] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR\n
$GLSL_DEFAULT_PRECISION_FLOAT\n
\n
$__HASHTAG__pragma vp_entryPoint "atmos_fragment_main"\n
$__HASHTAG__pragma vp_location   "fragment_lighting"\n
$__HASHTAG__pragma vp_order      "0.8"\n
\n
uniform bool oe_mode_GL_LIGHTING; \n
uniform float atmos_exposure;   // scene exposure (ground level)\n
varying vec3 atmos_lightDir;    // light direction (view coords)\n
varying vec3 atmos_color;       // atmospheric lighting color\n
varying vec3 atmos_atten;       // atmospheric lighting attentuation factor\n
varying vec3 atmos_up;          // earth up vector at fragment (in view coords)\n
varying float atmos_space;      // camera altitude (0=ground, 1=atmos outer radius)\n
varying vec3 atmos_vert; \n
        \n
vec3 oe_global_Normal;          // surface normal (from osgEarth)\n
\n
void atmos_fragment_main(inout vec4 color) \n
{ \n
    if ( oe_mode_GL_LIGHTING == false )\n
    {\n
        return; \n
    }\n
\n
    vec3 ambient = gl_LightSource[0].ambient.rgb;\n
    float minAmbient = ambient.r;\n
\n
    vec3 N = normalize(oe_global_Normal); \n
    vec3 L = normalize(atmos_lightDir); //normalize(gl_LightSource[0].position.xyz); \n
    vec3 U = normalize(atmos_up); \n
\n
    const float maxAmbient = 0.5;\n
    float daytime = max(0.0, dot(U,L));\n
    float brightness = clamp(daytime, minAmbient, maxAmbient);\n
\n
    float NdotL = max(dot(N,L), 0.0);\n
\n
    const float lowAlt  = 1.0;\n
    const float highAlt = 4.0;\n
    float altitudeInfluence = 1.0 - clamp( (atmos_space-lowAlt)/(highAlt-lowAlt), 0.0, 1.0);\n
    float useNormals = altitudeInfluence * (1.0-brightness);\n
\n
    // try to brighten up surfaces the sun is shining on\n
    float overExposure = 1.0;\n
\n
    // calculate the base scene color. Skip ambience since we'll be\n
    // factoring that in later.\n
    vec4 sceneColor = mix(color*overExposure, color*NdotL, useNormals);\n
\n
    if (NdotL > 0.0 ) { \n
        vec3 V = normalize(atmos_vert); \n
        vec3 H = normalize(L-V); \n
        float HdotN = max(dot(H,N), 0.0); \n
        float shine = clamp(gl_FrontMaterial.shininess, 1.0, 128.0); \n
        sceneColor += gl_FrontLightProduct[0].specular * pow(HdotN, shine); \n
    } \n
\n
    // clamp the attentuation to the minimum ambient lighting:\n
    vec3 attenuation = max(atmos_atten, ambient); \n
\n
    // ramp exposure from ground (full) to space (50%).\n
    float exposure = atmos_exposure*clamp(1.0-atmos_space, 0.5, 1.0); \n
\n
    vec3 atmosColor = 1.0 - exp(-exposure * (atmos_color + sceneColor.rgb * attenuation)); \n
    color.rgb = gl_FrontMaterial.emission.rgb + atmosColor; \n
}\n
\n
);

    Moon_Vert = "SimpleSky.Moon.vert.glsl";
    _sources[Moon_Vert] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR\n
$GLSL_DEFAULT_PRECISION_FLOAT\n
\n
uniform mat4 osg_ModelViewProjectionMatrix;\n
varying vec4 moon_TexCoord;\n
\n
void main() \n
{ \n
    moon_TexCoord = gl_MultiTexCoord0; \n
    gl_Position = osg_ModelViewProjectionMatrix * gl_Vertex; \n
}\n
\n
);

    Moon_Frag = "SimpleSky.Moon.frag.glsl";
    _sources[Moon_Frag] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR\n
$GLSL_DEFAULT_PRECISION_FLOAT\n
\n
varying vec4 moon_TexCoord;\n
uniform sampler2D moonTex;\n
\n
void main( void ) \n
{ \n
   gl_FragColor = texture2D(moonTex, moon_TexCoord.st);\n
}\n
\n
);

    Stars_Vert = "SimpleSky.Stars.vert.glsl";
    _sources[Stars_Vert] = OE_MULTILINE($__HASHTAG__version 120\n
\n
uniform vec3 atmos_v3LightDir; \n
uniform mat4 osg_ViewMatrixInverse; \n
varying float visibility; \n
varying vec4 osg_FrontColor; \n
\n
float remap( float val, float vmin, float vmax, float r0, float r1 ) \n
{ \n
    float vr = (clamp(val, vmin, vmax)-vmin)/(vmax-vmin); \n
    return r0 + vr * (r1-r0); \n
} \n
\n
void main() \n
{ \n
    osg_FrontColor = gl_Color; \n
    gl_PointSize = gl_Color.r * 14.0; \n
    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; \n
    vec3 eye = osg_ViewMatrixInverse[3].xyz; \n
    float hae = length(eye) - 6378137.0; \n
    // highness: visibility increases with altitude\n
    float highness = remap( hae, 25000.0, 150000.0, 0.0, 1.0 ); \n
    eye = normalize(eye); \n
    // darkness: visibility increase as the sun goes around the other side of the earth\n
    float darkness = 1.0-remap(dot(eye,atmos_v3LightDir), -0.25, 0.0, 0.0, 1.0); \n
    visibility = clamp(highness + darkness, 0.0, 1.0); \n
}\n
\n
);

    Stars_Frag = "SimpleSky.Stars.frag.glsl";
    _sources[Stars_Frag] = OE_MULTILINE($__HASHTAG__version 120\n
\n
varying float visibility; \n
varying vec4 osg_FrontColor; \n
\n
void main( void ) \n
{ \n
    float b1 = 1.0-(2.0*abs(gl_PointCoord.s-0.5)); \n
    float b2 = 1.0-(2.0*abs(gl_PointCoord.t-0.5)); \n
    float i = b1*b1 * b2*b2; \n
    gl_FragColor = osg_FrontColor * i * visibility; \n
}\n
\n
);
    
    Stars_GLES_Vert = "SimpleSky.Stars.GLES.vert.glsl";
    _sources[Stars_GLES_Vert] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR \n
$GLSL_DEFAULT_PRECISION_FLOAT \n
\n
uniform vec3 atmos_v3LightDir; \n
uniform mat4 osg_ViewMatrixInverse; \n
varying float visibility; \n
varying vec4 osg_FrontColor; \n
\n
float remap( float val, float vmin, float vmax, float r0, float r1 ) \n
{ \n
    float vr = (clamp(val, vmin, vmax)-vmin)/(vmax-vmin); \n
    return r0 + vr * (r1-r0); \n
} \n
\n
void main() \n
{ \n
    osg_FrontColor = gl_Color; \n
    gl_PointSize = gl_Color.r * 2.0; \n
    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; \n
    vec3 eye = osg_ViewMatrixInverse[3].xyz; \n
    float hae = length(eye) - 6378137.0; \n
    // highness: visibility increases with altitude\n
    float highness = remap( hae, 25000.0, 150000.0, 0.0, 1.0 ); \n
    eye = normalize(eye); \n
    // darkness: visibility increase as the sun goes around the other side of the earth\n
    float darkness = 1.0-remap(dot(eye,atmos_v3LightDir), -0.25, 0.0, 0.0, 1.0); \n
    visibility = clamp(highness + darkness, 0.0, 1.0); \n
}\n
\n
);

    Stars_GLES_Frag = "SimpleSky.Stars.GLES.frag.glsl";
    _sources[Stars_GLES_Frag] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR \n
$GLSL_DEFAULT_PRECISION_FLOAT \n
\n
varying float visibility; \n
varying vec4 osg_FrontColor; \n
void main( void ) \n
{ \n
    gl_FragColor = osg_FrontColor * visibility; \n
}\n
\n
);

    Sun_Vert = "SimpleSky.Sun.vert.glsl";
    _sources[Sun_Vert] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR\n
$GLSL_DEFAULT_PRECISION_FLOAT\n
\n
varying vec3 atmos_v3Direction; \n
\n
void main() \n
{ \n
    vec3 v3Pos = gl_Vertex.xyz; \n
    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; \n
    atmos_v3Direction = vec3(0.0,0.0,1.0) - v3Pos; \n
    atmos_v3Direction = atmos_v3Direction/length(atmos_v3Direction); \n
}\n
\n
);

    Sun_Frag = "SimpleSky.Sun.frag.glsl";
    _sources[Sun_Frag] = OE_MULTILINE($__HASHTAG__version $GLSL_VERSION_STR \n
$GLSL_DEFAULT_PRECISION_FLOAT \n
\n
uniform float atmos_sunAlpha; \n
varying vec3 atmos_v3Direction; \n
\n
float atmos_fastpow(in float x, in float y) \n
{ \n
    return x/(x+y-y*x); \n
} \n
\n
void main( void ) \n
{ \n
   float fCos = -atmos_v3Direction[2];          \n
   float fMiePhase = 0.050387596899224826 * (1.0 + fCos*fCos) / atmos_fastpow(1.9024999999999999 - -1.8999999999999999*fCos, 1.5); \n
   gl_FragColor.rgb = fMiePhase*vec3(.3,.3,.2); \n
   gl_FragColor.a = atmos_sunAlpha*gl_FragColor.r; \n
}\n
\n
);
}
